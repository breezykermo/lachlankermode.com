---
title: the towpath to React and Redux
date: "2016-07-28T16:12:51.247Z"
layout: post
path: "/the-towpath-to-react-and-redux/"
---

When you visit a URL, you are redirected through the internet to a server somewhere in the world, and code is triggered on that server, prompted by your request. Sometimes that code makes requests elsewhere, retrieving other resources from a database or elsewhere before returning files to your browser, which we can call the *client*, that made the request. This is how the Facebook page that you see when you visit facebook.com is different from your friends'. Even though you could both be at the same URL; the page is customized at the server-side before it is returned to your browser through the login parameters that you sent.

In simpler sites, such as [lachlankermode.com](http://lachlankermode.com/)[^1], when there are no required exterior resources and no customization, the server simply directly returns HTML, CSS and Javascript files to your browser. Browsers have been programmed to interpret these filetypes. They know how to render in color and glory the wonderful web pages that we can browse on the internet. This was really the paradigm in which the web was originally designed; it was built as a forum for the retrieval and consequent display of HTML documents.

However, we have come to expect much more of the web in 2016. Sites ought to be dynamic, viewable and beautiful from many different shapes and sizes of device, and they should interactively update based on where I click, swipe and hover. Back in 1994[^2], [Brendan Eich created Javascript](http://speakingjs.com/es5/ch04.html) at Netscape. Javascript was conceived to run in the browser on the client side to make the experience of the web more dynamic: through Javascript, the browser could partially update and modify HTML documents in response to events, such as clicks and hovers. Event handlers in Javascript could also asynschronously request resources across the web, read and write to the user's local file system, among many other capabilities.

Javascript's relationship with the original conception web of documents is really the core of how the web works today. It enables the dynamic experience of data and documents that we expect and encounter every time we open a browser. The web is more than just an organically organized global file cabinet; it is an enormous network of theatrical data exhibitions that personally interact with each visitor, exhibitions that communicate with each other in non-trivial ways.

The web's origin and history are inscribed in its practice today. The exhibitions we call websites are built on top of original document structure of the web, and the friction between what the web was and what it has become is keenly felt by those of us who develop on its platform. Programming for browsers, which we can more technically call the *Document Object Model* (or the *DOM*), is a matter of negotiating many minute updates to an HTML document in response to a range of events, all computed against the dimension of time[^3].

Libraries like [jQuery](https://jquery.com/) emerged to provide ways of managing these updates and manipulations, and they were soon followed by frameworks like [AngularJS](https://angularjs.org/) and [Backbone](http://backbonejs.org/), which offer extensive suites replete with solutions to the common and immediate complexities of developing with the DOM in Javascript. Equipped with these tools, developers were able to build softer, warmer single-page-application flesh around the web's document bones. The experience of HTML in the DOM grew into the performative and interactive showcase we know and adore day-to-day in our quotidian rituals.

But as applications like Facebook became larger and larger, and increasingly complex, developers discovered that it was very hard to keep track of everything that was being updated on each event. Developers found that in attempting to change one thing, often something that seemed simple and straightforward, they would routinely break some other part of the system. In more complex applications, it was difficult to know which events were being triggered where, or how exactly data was being fed into the DOM.

In this era of complexity, unidirectional data flow was born, pomaded by a sexy midwife, [React](https://facebook.github.io/react/index.html). The basic idea of unidirectional data flow is explicitly simple: data should flow in one direction conceptually for the developer, so that it is easy to keep track of. Updates to the DOM ought to be administed one at a time, in a traceable way, and preferably from one single source of truth, so that the range of updates and insertions are transparent to the developer. Parts of the DOM should not be able to reach out to a distant cousin of the DOM and change it without telling anything else. [React](https://facebook.github.io/react/index.html) is a very popular library that breaks up the view layer of an application into citizens that listens for changes from some authority, and it calls these citizens components.

A React component is rendered with a set of input values which are called *props*. Each time the props for a component changes, the entire component re-renders. In other words, a React component is a UI expression of the data that is passed into it. When the input data changes, the function is called again with the new data. React components can call functions that make or request changes to an external store, from which they then in turn receive their props. Data flows in one direction, and can always be intercepted and explicitly monitored in the application state[^4].

![One Way Data Flow](/React1.png)

React's conceptual simplicity is made performant through some very clever way of hacking the DOM's core architecture. Because the DOM was designed to render entire documents, it is not really very good at making incremental changes to those documents, and therefore as developers we want to limit DOM updates to those that are necessary; we don't want to overwrite parts of the DOM with nodes to refresh entire components in the DOM when only a small part of the UI has changed.

React affords developers the conceptual benefit of full component re-rendering, but also only makes necessary changes to the DOM by using a *virtual DOM*. When a component's props change, the virtual DOM handles the component re-render in a less computationally expensive virtual arena, and then uses a [clever diffing algorithm](https://facebook.github.io/react/docs/reconciliation.html) to determine which specific updates need to be made in the real DOM. This wonderful abstraction mediates between the developer's experience of application development and the DOM's anatomical requirements.

A core contributor to React's popularity in the web development community is the canon of state management solutions that is conceived alongside React itself; architectures for the external store to which React components subscribe and from which they receive their props. The most popular of these at the moment is [Redux](https://github.com/reactjs/redux), a library written by [Dan Abramov](https://github.com/gaearon) inspired by techniques in Elm and other functional programming languages. Redux offers a very robust architecture for managing the external store in React applications.

![Redux Architecture](/React2.png)

Redux popularity skyrocketed after Dan Abramov [demonstrated what was possible](https://www.youtube.com/watch?v=xsSnOQynTHs) in the way of developer tools--explicit changelogs, hot reloading, and even time travel. Redux became the most popular [Flux](https://facebook.github.io/flux/) implementation, Facebook's suggested solution for managing state in React applications. One of the keys to Redux's popularity is its extensibility. It is an architecture for state management, not an already constructed building you have to drop into your application. Managing updates to the store from asynchronous data sources, for example, is not a prebuilt capability in Redux, it rather has [several](https://github.com/gaearon/redux-thunk) possible [solutions](https://github.com/yelouafi/redux-saga).

React's ethos of hacking existing anatomy to ease cognitive burden for the developer is unsurprisingly popular in the developer community, as it makes programming applications easier and, more importantly, more fun. This ethos has found its way to mobile development as well, in [React Native](https://facebook.github.io/react-native/). React Native allows you to write native mobile applications for iOS and Android in Javascript using React, by running a Javascript thread alongside the native language (Objective C for iOS and Java for Android). These threads communicate with each other through a bridge, over which data and event notifications are passed. This allows React Native to leverage the perfomance of native UI views and code for computationally expensive operations, and to program less expensive application logic on the Javascript thread through React. [There are potential benefits here](https://www.smashingmagazine.com/2016/04/consider-react-native-mobile-app/) for developer cognitive burden and experience, just as in React for the web.

React and its contingent libraries are most interesting to me not as ways to improve iteration or application stabilty in industry software development (the standard evangelizations of React), but as a robust and elegant philosophy for dealing with complexity. If there is anything I can believe in, any concept of 'productivity' that seems worth striving for, it is simplifying complexity. This is one of the reasons I like programming; programming is the practice of using abstraction to manage complex anatomies, often otherwise unassailable. This is possibly the imperative of all thought we inscribe as meaningful--science, philosophy, political science, literature, music--it all looks to 'explain': to rethink complex anatomies via 'simpler' abstractions, thought configurations that are more sympathetic with the current river of our consciousness[^5].

[^1]: Shameless plug; this is my website after all.
[^2]: Incidentally the year I was born.
[^3]: Programming languages have lots of interesting ways of abstracting time (or asynchronous operation) for the developer, and Javascript is no exception. The language's most recent specification, [ES2015](http://www.ecma-international.org/ecma-262/6.0/), includes callbacks, promises and generators, to name a few.
[^4]: Note that React also provides a solution for storing and redistributing data, the `state` of a React component. React components can hold state and modify parts of the DOM within their own assigned territory; but the core philosophy of React wants to defer most authority to a higher truth. React component `state` is a capability that allows distribution of authority within reasonable constraint. It's overwrought and possibly melodramatic to defer *every little update* to a centralized control station.
[^5]: A big thanks to Daniel, Karina and Kevin for reviewing this article and providing feedback.